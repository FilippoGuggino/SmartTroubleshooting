"""
This module provides a set of API to access data preparation services.

Author: Filippo Guggino
"""

import os
import csv
import threading
from datetime import datetime
from smart_troubleshooting.file_io import dump_csv, dump_json, load_json
from smart_troubleshooting.pd_preparation_system.word_embedding_manager \
    import WordEmbeddingManager


class PDPreparationSystemService:
    """
    This class provides a set of API to access data preparation services:
        - fetch of problem description generated from the segregation service
        - data manipulation
        - sentence embedding
        - dump feature vectors of previously retrieved problem descriptions for:
            - NN training (see pd_similarity_dev_system)
            - usage from the user (see troubleshooting_system)

    Author: Filippo Guggino
    """

    _problem_mapping_path = "segregation_system/csv/ProblemMappingFile.csv"
    _feature_vector_output_file = "pd_preparation_system/csv/FeatureVectorOutputFile.csv"
    _preparation_report_file = "pd_preparation_system/json/preparationReport.json"

    def __init__(self):
        config_path = "pd_preparation_system/json/preparationServiceConfig.json"
        if os.path.exists(config_path):
            self._load_configuration(config_path)

    def _load_configuration(self, config_path):
        config_data = load_json(config_path)
        self._problem_mapping_path = config_data['problem_mapping_path']
        self._feature_vector_output_file = config_data['feature_vector_output_file']
        self._preparation_report_file = config_data['preparation_report_file']

    def _write_report(self, exit_status, error_message=None):
        report_json = {"exitStatus": exit_status,
                       "errorMessage": error_message,
                       "lastSegregationTime": str(datetime.now())}

        dump_json(report_json, self._preparation_report_file)

    def _wait_for_problem_mapping_file(self):
        """
            Check if problem mapping file(containing problem description) has been
            created. If so, continue with the procedure.

            :returns: True if the problem mapping file is present
            :rtype: boolean
        """
        if not os.path.exists(self._problem_mapping_path):
            return False

        if os.path.isfile(self._problem_mapping_path):
            print("ProblemMappingFile found!")
            return True

        raise ValueError("%s isn't a file!" % self._problem_mapping_path)

    def _retrieve_problem_mapping_data(self):
        """
            Retrieve from problem mapping file generated by the segregation system all
            problem descriptions in order to normalize its content and then perform
            sentence embedding.

            :returns:
            :rtype: array of dictionaries:
                {
                    "problem_id": string
                    "problem_description": string
                }
        """
        with open(self._problem_mapping_path) as problem_mapping_file:
            problem_mapping_data_reader = csv.DictReader(problem_mapping_file, delimiter=',')

            problem_mapping_data = []
            for problem_des in problem_mapping_data_reader:
                problem_mapping_data.append(problem_des)

        # Remove old feature vector file
        os.remove(self._problem_mapping_path)

        return problem_mapping_data

    def schedule_preparation_procedure(self, period=1):
        """
            Periodic scheduling of the pd preparation procedure. Used during
            normal usage of the application, waiting for every request from the user.

            :param period: period (in seconds) between each call of the preparation procedure
            :type period: integer
        """
        self.activate_pd_preparation_procedure()

        threading.Timer(period,  # re-init timer
                        self.schedule_preparation_procedure).start()

    def activate_pd_preparation_procedure(self):
        """
            Implements basic functionalities of the preparation service:
                - read problem description from the "ProblemMappingFile.csv"
                - data manipulation/normalization
                - sentence embedding
                - save problems' feature vectors on the "FeatureVectorOutputFile.csv"
        """
        word_embedding_manager = WordEmbeddingManager()

        if not self._wait_for_problem_mapping_file():
            return

        problem_mapping_data = self._retrieve_problem_mapping_data()

        if len(problem_mapping_data) == 1:
            self._write_report("ERROR", "ProblemMappingFile is empty. Check Segregation System.")
            print("ProblemMappingFile is empty. Check Segregation System.")
            return

        sentence_list = [problem['problem description'] for problem in problem_mapping_data]
        id_list = [problem['problem id'] for problem in problem_mapping_data]
        sentence_embeddings = word_embedding_manager.create_feature_vector(sentence_list)
        head_rows = ["problem_id", *[f"feature{i}" for i in range(len(sentence_embeddings[0]))]]

        feature_vector_output = []
        for problem_id, sentence_embedding in zip(id_list, sentence_embeddings):
            feature_vector_output.append(
                dict(zip(head_rows, [problem_id, *sentence_embedding])))

        dump_csv(head_rows, feature_vector_output, self._feature_vector_output_file)
        self._write_report("OK")
